恶狼战役是在主程序开发完成后，才真正开始的一个项目，乐趣在于大家编写自己的指挥程序，战胜别人。

编写指挥程序可以参看 feardFarmers.erl 【恐惧的农民】，englandArmy.erl 【英格兰卫兵】 两个例子程序，以及本文档了解开发指挥程序的接口规范。然后就看你的聪明智慧了。。。

大家如果开发你自己的指挥程序，建议：

  1. 用 eb0/youname/armyname.erl 的方式命名。 每人维护自己的指挥程序，不要改别人的。除非你们计划一起做一个
  1. 给你的算法取一个形象的名字。例如我们说的【恐惧的农民】和【英格兰卫兵】 ，能够很好的描述你的算法特点。

> 【恐惧的农民】名称来自于这个算法吓得指令都不发，部队就在原地呻吟，求饶

> 【英格兰卫兵】名称来自于这个算法指挥部队一直往前走，不带拐弯的，直到碰到人，然后就往死里砍。 很像英国人的直脑筋

**-如果你想把你的算法保密，免得别人知道你的指挥策略，可以仅交付.beam 文件，参加比赛。 可以不提交代码。**


---


## 接口环节简述 ##

1. 启动

> 要实现一个run(Channel, Side，Queue)  的函数，并export 出来。 主程序会在战斗启动后调用这个程序

> 其中Channel 是你发送指令去的进程，这个进程是你自己独享的，注意不要狂发消息阻塞你自己的指令队列。

> Side 是告诉你，你在本次战斗中属于红方，还是蓝方。 取值 blue, red

> Queue 是你这方的指令队列的ID


2. 了解当前战场情况

> 你可以查看三个只读的ETS 表，获得战场信息

> 战场时钟：battle\_timer  [ets表]

> 战场状况：battle\_field  [ets表]

> 指令队列表：Queue [表](ets.md)  （注意这个给的是ID ,而不是表名。上两个是named ets, 这个不是named）


3. 指挥你的部队

> Channel ! {command,"attack",Soldier,0,0};  向Channel 发送你的指令

4. 战斗结束后收尾

> 一般不需要处理这个接口，但是如果你在决策过程中使用了ets表， 那么最好在进程结束前把它delete 掉。

> 当主程序结束的时候，会用： exit(Commander, finish) 命令来杀掉你的进程。如果你什么都处理，就会立即被杀掉。 如果你想处理这个消息，再被杀掉前做点收尾工作，那么请参见englandArmy.erl 代码。

5. EB整体架构

> [EB:如何控制战场时间节拍和指令时序](EbSequenceDesign.md)



---



## 接口详细描述 ##

1. 战场时间钟（battle\_timer)

> 一个就一个字段的命名的 protected ETS 表
  * clock
  * 当前时间

2.战场状态（battle\_field)

> 使用命名的 protected ETS 表
> 结构：

  * 战士编号 {id, side}   (死亡后，从表中删除） id 取值1-10， side 取值blue, red
  * 位置 （x, y）
  * 血量  1 - 100
  * 面朝的方向  （north,west,south,east）  ---北南西东---或者说上下左右
  * 当前动作 (无动作 wait,  前进 forward, 后退 back, 转向（turnSouth, turnNorth, turnWest,turnEast）, 攻击 attack)
  * 当前动作生效时间
  * 行动次序

其中：
> 位置按照坐标第一向限的方式描述。 左下为 0，0 ，  右上为 （14，14）

> 考虑到未来图形化显示的问题，部队为左右进攻。

> 因此初始时：

> 左边部队（红）为：0，3 - 0，12

> 右边部队（蓝）为：14，3 - 14，12


3. 命令消息

> {command , 指令, 发起的战士，发动时间, 发动次序}

> 其中指令为：    前进 forward, 后退 back, 转向（turnSouth, turnNorth, turnWest,turnEast), 攻击 attack, 原地待命 wait

> 发动时间：指希望该动作在哪个时间点发动。 比如我们希望部队在统一时间向前前进一步。而不希望他们乱走。  发动时间如果是 0  则表示希望立刻发动该动作。

> 发动次序：控制同一轮内，哪些动作优先发动。 数值越小，越会优先发生。详见[同一轮动作优先级判定](http://code.google.com/p/erlbattle/wiki/EbSeqAtSameRound) 一文

> 你如果一个节拍发送多个指令，前面的指令会被冲掉。主程序每个节拍会对于当前没有任务的战士取一次指令，取完后会删掉。 未被取走的指令留在那里，直到被冲掉，或者被取走；

> 理论上来讲你是不需要看这个队列的，你自己发了什么指令你自己应该清楚。 但是如果你发多了，搞不清楚到底如何，可以看这个队列表。



---



## 参考：战场主程序对于命令队列的管理 ##

> 主程序使用两个ETS 管理各自的指令队列。每个战士同时只有一个指令缓存，如果这个指令没有执行，新的指令进来的话，就会冲掉老的指令。

> 战场每个节拍先把在BattleField 表中体现的当前动作能够完成的先完成（比如攻击需要两个节拍，如果上一个刚刚发起的攻击，这个节拍不会完成，就要等待该动作完成后才接受新的任务指令）。然后对处于没有任务状态的战士到队列中找下一个指令。此时有三种可能，

> a. 没有指令：  战士不动

> b. 有指令，该指令的生效时间小于等于当前时间，或者等于0 ； 此时就会安排战士执行这个动作。

> c. 有指令，但该指令的生效时间大于当前时间； 此时战士仍然不动


> 对于b 情况，将指令放到状态表中（表明动作开始发生了），根据每个动作的开销， 计算预计产生效果的时间。



