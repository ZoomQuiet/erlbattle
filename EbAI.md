

# EB世界 #
`EB是个真实的世界。我们可以这样理解：`
  * EB是个棋盘类的博弈游戏。
> > 想像一下，你与对手有1分钟的思考用时，1分钟后你们一起移动棋子。
> > 只不过在EB中，棋子的移动，按照方式的不同，耗时也不同。
> > 基于这一点，规则稍微变化一下，你与对手每隔1分钟可以移动棋子，棋子移动结束后才可以继续移动。棋子按照移动方式，耗时1分钟-4分钟不等。

  * EB是个砖块环境的实时战略游戏。
> > EB的节拍我们可以认为是游戏主控逻辑的一个循环。我们可以在每个节拍计算我们的NPC的位置信息并更新。(跟通常的游戏不同，在EB中，我们的NPC是全能的神，他们可以知道战场上任意一个NPC的情况：位置、状态等。:))

  * EB是个战场模拟程序。
> > 我们有10个士兵，但是我们可以增加自己的通讯指挥系统。这个在ERLANG中很方便，生成进程，发消息即可。士兵们或者自己行动，或者接受指挥统一行动。
  * ……


> 不论如何，我们可以按照我们喜欢的方式，理解EB，建模EB，享受战斗，享受生活。:)

# 目标 #
> 我希望我的部队有自己的决策系统，可以针对较复杂的情况进行有限的自行判断，而不是受限于特定的几种行动模式。

# 寻路 #
> 寻路，顾名思义，寻找路径。

> 这是基本的算法，任何游戏都要用到。怎样走到敌人跟前？走哪条路最近？中间有障碍物怎么办？这些都要用到寻路算法。

## 视线追逐算法 ##
> 在砖块环境中，从一点移动到另外一点，简单有效的直线算法，就是Bresenham算法了。
> [这里](http://erlbattle.googlecode.com/files/ai.7z)做了一个简单的实现。

## A\*算法 ##
> A\*算法是个适用范围很广泛的寻路算法。它可以很好的处理途中遇见的障碍物，从而得到一条最好的路线。注意，找到的路线只是所有最好路线中的一条，但是可以保证不会有更好的路线没找到。
> A\*算法是把Dijkstra算法和BFS算法结合的产物。它在搜索过程中像BFS一样使用启发式函数引导搜索过程。在从起点走向终点的过程中，A\*会检查f(n)值最小的节点，其中f(n)=g(n)+h(n)。这里，g(n)就是起点到任意节点n的代价，h(n)是任意节点n到终点的评估代价。
> g(n)很容易得到，所有的信息都保存着。重要的是h(n)。在砖块环境中，最常用的h(n)就是曼哈顿距离：
> h(n) = abs(n.x – goal.x) + abs(n.y – goal.y)
> 很符合我们EB环境。哈哈

> 按照书A的内容：实现了一个A\*算法。在[这里](http://erlbattle.googlecode.com/files/ai.7z)。
> 伪码：

```
 起点加入open list
 while open list 不空
 {
   当前节点 = open list中成本最低的节点
   if 当前节点 = 终点 then
    完成
   else
    当前节点加入closed list
    for 每个相邻节点
     if 该节点不在open list
      and 不在closed list
      and 不是障碍物
        该节点加入open list，计算成本
 }
```

# 参考书籍 #
  * 书A：[《游戏开发中的人工智能》](http://groups.google.com/group/erlbattle/files)